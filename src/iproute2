#! library/module/for/bash
#
# ip (iproute2) command-line completion for Bash.
#
# Written by Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Released at LCA2010, 19 January 2010.
# Updated to use proper parser state-stack April 2012.
#
# You may copy and use this program under the terms of version three of the Gnu
# Public Licence, or any later version as published by the Free Software
# Foundation.
#

[[ $(type -t have) != function ]] || have ip || return

__ip_slurp() {
    sed -e '
             s/#.*//
             s/[        ][      ]*/ /g
             s/ $//
             s/^[0-9][0-9]* //
             /^$/d
             s/ /\n/g
            ' $1
}

__ip_strtrunc() {
    local w=$1 ; shift
    local p="$*"
    ((${#p} > w)) && p="${p:0:w-3}..."
    echo "$p"
}

__ip_debug() { : ; }
__ip_debug_parsing_state() { : ; }
__ip_debug_unexpected() { : ; }
__ip_error() { break 2 ; }
__ip_warning() { : ; }

__ip_map() {
    local ___f="$1" ___i ___r=
    shift
    for ___i do
        ___r+=" $(set -- "$___i" ; eval $___f)"
    done
    echo $___r
}

__ip_prefix_map() {
    local ___p=$1
    shift
    __ip_map 'echo $___p$1' "$@"
}

__ip_seq() {
    local i=$1 e=$2 ___p=$3 ___s=$4 ___r=
    for ((;i<=e;i++)) do
        ___r+="$___p$i$___s "
    done
    echo $___r
}

__ip_match_number() {
    local _p _t __set_var= __max= __min=0 __ignore_prefix= __radix=auto __fake_cur
    while [[ $1 = -* ]]
    do
        case $1 in
        ( --[0-9]*bit )     __max=${1##*[^0-9]} __max=${__max%%[^0-9]*} ; ((__min=0, __max=(1<<__max)-1)) ;;
        ( --max*=* )        __max=${1#--*=} ;;
        ( --min*=* )        __min=${1#--*=} ;;
        ( --s*[0-9]*bit )   __max=${1##*[^0-9]} __max=${__max%%[^0-9]*} ; ((__min=(-1<<__max-1), __max=(1<<__max-)-1)) ;;
        ( -A )              __radix=auto ;;
        ( -C* )             __fake_cur=${1#-?} ;;
        ( -N )              __ignore_prefix='*[^0-9a-f]' ;;
        ( -P )              __ignore_prefix=$2 ; shift ;;
        ( -P?* )            __ignore_prefix=${1#-?} ;;
        ( -B?* )            __radix=${1##*[^0-9]} ;;
        ( -V )              __set_var=_V ;;
        ( -V?* )            __set_var=${1#-?} ;;
        (*)                 __ip_error "Invalid option '$1' to __ip_match_number" ;;
        esac
        shift
    done

    local __cur="${__fake_cur-${COMP_WORDS[cword_index]}}"
    local __num="${__cur##$__ignore_prefix}"
    local __saved_prefix="${__cur%"$__num"}"
    local __neg="${__num%%[^-]*}" ; __num="${__num#"$__neg"}" __neg="${__neg#----}" __neg="${__neg#--}"

    if ((cword_index==COMP_CWORD))
    then
        __ip_debug "MATCHNUM $*"
        if [[ $__radix = auto ]]
        then
            case $__cur in
            (0x*) __radix=16 ;;
            (0*)  __radix=8 ;;
            (*)   __radix=10 ;;
            esac
        fi
        if
            local __rp=
            case $__radix in
            (8)  __rp=0  ; [[ $__num != *[^0-7]* ]]    ;;
            (10)           [[ $__num != *[^0-9]* ]]    ;;
            (16) __rp=0x ; [[ $__num != *[^0-9a-f]* ]] ;;
            (*)  __ip_error "Radix $__radix is not supported" ;;
            esac
        then
            __num=${__num#$__rp}
            __num=${__num#0000} __num=${__num#00} __num=${__num#0}
            if [[ $__neg = - ]]
            then
                case $__min:$__max in
                (:?*)   ((__min=-__max)) ; __max= ;;
                (*?:)   ((__max=-__min)) ; __min= ;;
                (*?:?*) eval "(( __min=-($__max), __min=-($__min) )) " ;;
                esac
            fi

            local __i
            (( __i = $__rp${__num:-0} ))

            [[ -n $__set_var ]] && eval "(( $__set_var = __i ))"

            (( __min <= __i && __i <= __max )) && COMPREPLY+=("$__cur")

            local __min_digit __max_digit

            (( __offset = __i * __radix ))
            while
                (( __min_digit = (${#__min}==0 || __min < __offset ? 0 : __min - __offset),
                   __max_digit = (${#__max}==0 || __max >= __offset+__radix ? __radix-1 : __max - __offset ) ))
                (( __min_digit >= __radix ))
            do
                __ip_debug "MATCHNUM: $__cur->$__rp$__num->$__i radix=$__radix offset=$__offset (min=$__min max=$__max) -> (min_digit=$__min_digit max_digit=$__max_digit) RETRY"
                (( __min/=__radix, __max/=__radix ))
            done
            __ip_debug "MATCHNUM: $__cur->$__rp$__num->$__i radix=$__radix offset=$__offset (min=$__min max=$__max) -> (min_digit=$__min_digit max_digit=$__max_digit)"

            local -a __digits=( 0 1 2 3 4 5 6 7 8 9 a b c d e f )
            for ((__i=__min_digit;__i<=__max_digit;++__i)) do
                COMPREPLY+=("${__cur}${__digits[__i]}")
            done
        else
            __ip_warning "MATCHNUM $__cur not suitable for radix $__radix"
        fi
        return 1
    else
        __ip_debug "PARSENUM $*"
        [[ -n $__set_var ]] && eval "(( $__set_var = __cur ))"
        [[ $__cur = ?*   && $__cur != *[^0-9]*      ]] && return 0
        [[ $__cur = 0x?* && $__cur != 0x*[^0-9a-f]* ]] && return 0
        [[ $__radix = 16 && $__cur != *[^0-9a-f]*   ]] && return 0
        return 1
    fi
}

#
# __ip_match relies on two external variables: COMP_WORDS[], COMP_WORD & cword_index.
#
# the match-list elements are of the form word[=token]
# the word is included in COMPREPLY
# if a token is given, it is used to set the -S or -V parameter, otherwise word is used
# (this simplifies aliases such as list/show)
#

__ip_match() {
    local __seen_pref= _p= _t= __set_var= __cur=
    while [[ $1 = -* ]]
    do
        case $1 in
        ( -S )      __seen_pref=$2 ; shift ;;
        ( -S?* )    __seen_pref=${1#-?} ;;
        ( -V )      __set_var=_V ;;
        ( -V?* )    __set_var=${1#-?} ;;
        (*)         __ip_error "Invalid option '$1' to __ip_match" ;;
        esac
        shift
    done
    if ((cword_index==COMP_CWORD))
    then
        __ip_debug "MATCH $*"
        if [[ -n $__seen_pref ]]
        then
            for _p do
                _p="${_p%=*}"
                [[ $_p != *[^_a-z0-9]* && $_p != [0-9]* ]] &&
                    eval \${${__seen_pref}$_p:+:} false && {
                    __ip_debug "Excluding $_p (already seen)"
                    continue
                }
                __ip_debug "Including $_p (not already seen)"
                COMPREPLY+=( "$_p" )
            done
        else
            __ip_debug "Including all of [$*] (not tracking 'seen')"
            COMPREPLY+=( "${@}" )
        fi
        return 1
    else
        __ip_debug "PARSE $*"
        __cur=${COMP_WORDS[cword_index]}
        for _p do
            _t="${_p##*=}" _p="${_p%=*}"
            [[ $__cur = ?* && $_p = $__cur* ]] || continue
            [[ -n $__seen_pref && $_p != *[^_a-z0-9]* && $_p != [0-9]* ]] && {
                eval $__seen_pref$_p=true
                __ip_debug "Remembering that $_ has been seen"
            }
            [[ -n $__set_var ]] && {
                __ip_debug "SETTING $__set_var='${_t}'"
                eval $__set_var='${_t}'
            }
            return 0
        done
        return 1
    fi
}

__ip_match_addr() {
    local accept_link=false accept_ipv4=false accept_ipv6=false accept_prefix=false \
          accept_default=false possibly_complete=false definitely_complete=false \
          require_prefix=false require_multicast=false require_unicast=false
    local __set_var=

    while [[ $1 = -* ]]
    do
        case $1 in
        ( -V )          __set_var=_V ;;
        ( -V?* )        __set_var=${1#-?} ;;
        ( -0 )          accept_link=true ;;
        ( -46 | -64 )   accept_ipv4=true accept_ipv6=true ;;
        ( -4 )          accept_ipv4=true ;;
        ( -6 )          accept_ipv6=true ;;
        ( -p )          accept_prefix=true ;;
        ( -P )          require_prefix=true ;;
        ( -d )          accept_default=true ;;
        ( -a )          require_unicast=true ;;
        ( -m )          require_multicast=true ;;
        ( -* )          __ip_warning "Invalid option '$1' to __ip_match_addr" ; break 3 ;;
        (*) break ;;
        esac
        shift
    done

    local __cur="${COMP_WORDS[cword_index]}"

    __ip_debug "Completing address starting with '$cur': ipv4=$accept_ipv4 ipv6=$accept_ipv6 prefix=$accept_prefix/$require_prefix "

    case $__cur in
    (*.*.*.*.*|*:*:*:*:*:*:*:*:*)
                __ip_error "$__cur is not valid IPv4 or IPv6 address" ;;
    esac

    case $__cur in
    (*:*/*)     __ip_match_number -N -B10 --min=1 --max=128 ;;
    (*.*.*.*/*) __ip_match_number -N -B10 --min=1 --max=32  ;;
    (*.*)       __ip_match_number -N -A   --8bit ;;
    (::*)       __ip_match_number -N -B16 --16bit ||
                { [[ $__cur != ::*:* ]] && __ip_match_number -N -A --8bit ; } ;;
    (*:*)       __ip_match_number -N -B16 --16bit ;;
    (*)         __ip_match_number -N -A --8bit ||
                __ip_match_number -N -B16 --min=0x2000 --max=0x3fff ||
                __ip_match 0000: fc00:: fe80:: ;;
    (*)         false ;;
    esac ||

    case $__cur in
    (*/*)       false ;;
    (*.*.*.*|*::*|*:*:*:*:*:*:*:*)
                __ip_match $__cur/ ;;
    (*)         false ;;
    esac ||

    case $__cur in
    (*/*|*.*|*::|*::*:)
                false ;;
    (*)         __ip_match $__cur: ;;
    esac ||

    case $__cur in
    (*[:/a-f]*|*[^.][^.][^.][^.]|*.*.*.*|*.) false ;;
    (*)         __ip_match $__cur. ;;
    esac ||

    return $?

    [[ -n $__set_var ]] && eval "$__setvar=\"\$__cur\""

    return 0
}

#
# __ip_match_empty and __ip_match_fail may be called when other matching functions return non-zero;
# they take some rather peculiar action as a result:
#
# 'break' means the match loop will cease and possible completions computed so far will be used
# 'break 2' means all processing will immediately stop, and no completions will be available
# 'decrement cword_index and continue' means the match loop will start over, testing the same word against the previous non-terminal
#

__ip_match_empty()  {
    __ip_debug_parsing_state EMPTY
    ((--cword_index))
    continue
}

__ip_match_fail() {
    __ip_debug_parsing_state FAIL
    if ((__empty))
    then
        ((--cword_index))
        continue
    elif ((cword_index==COMP_CWORD))
    then
        break
    fi
    break 2
}

_ip() {
    # "seen" is stack of partial states, as a string separated by slashes, shallowest-to-deepest
    local seen=
    local cur="(start-of-line)"
    local cword_index=0
    local save_device=
    local save_ipv=-46
    local want=
    local max_num= min_num=
    local cur_is_decnumber=false cur_is_hexnumber=false
    local expecting=
    local seen_prefix=false

    COMPREPLY=()

    if $COMP_VERBOSE
    then
        echo >&2 $'\e7\e[A\e[999I\e[43;30m\e[1J\e[5H'"Completion START: WORDS=(${COMP_WORDS[*]}) CWORD=$COMP_CWORD"
        trap " trap RETURN ; echo -n >&2 'Completion END: COMPREPLY=('\${COMPREPLY[*]}')'\$'\\e[49;39;0m\\e8' " RETURN
        __ip_debug() { echo >&2 "Completion $*" ; }
        __ip_debug_parsing_state() { local tag=$1 ; shift ; echo >&2 "Completion STATE $tag word[$cword_index]=$cur seen=$seen $*" ; }
        __ip_debug_unexpected() { echo >&2 "Completion UNEXPECTED $*" ; }
        __ip_error() { echo >&2 "Completion ERROR $*" ; break 3 ; }
        __ip_warning() { echo >&2 "Completion WARNING $*" ; }
    else
        __ip_debug() { : ; }
        __ip_debug_parsing_state() { : ; }
        __ip_debug_unexpected() { : ; }
        __ip_error() { local t="  $*" ; local l=${#t} ; echo -n >&2 $'\e[1K\e[33m'$t$'\e[39m\e['$l'D' ; break 3 ; }
        __ip_warning() { : ; }
    fi

    for seen in START ; do  # {{{
        # dummy loop
        for ((cword_index=1;cword_index<=COMP_CWORD;cword_index++)) do  # {{{

            cur=${COMP_WORDS[cword_index]}

            __ip_debug_parsing_state P1

            [[ -n $want ]] && __ip_match "$want " && break

            want=

            local cur_is_decnumber=false cur_is_hexnumber=false
            [[ $cur != '' && $cur != *[^0-9]* ]] && cur_is_decnumber=true
            [[ $cur = 0x* && $cur != 0x*[^0-9a-f]* ]] && cur_is_hexnumber=true

            __ip_debug "word[$cword_index]=\"$cur\" seen=\"$seen\""

            local _s expecting=${seen##*/} ; seen=${seen%/*}

            [[ $expecting = =* ]] && want=${expecting#=} expecting=${seen##*/} seen=${seen%/*}

            local -a _S=()
            local __empty=

            [[ $expecting = '?'* ]] && __empty=1 expecting=${expecting#'?'}

            __ip_debug_parsing_state P2 expecting=$expecting ${want:+want=$want} ${__empty:+empty=$__empty}

            case $expecting in  # {{{

            (START)         __ip_match -V_s addr addrlabel link maddr monitor mroute neigh ntable route rule tunnel tuntap xfrm --batch --details --family --oneline --resolve -rcvbuf  --statistics --timestamp --verbose --Version -0 -4 -6 -b -d -f -o -r -s -t -v -V
                            case $_s in
                            (-f|--family) seen+=/FAMILY ;;
                            (-[46])   save_ipv=$cur ;;
                            (-b?*)    save_batchfile=${cur:2} ;;
                            (-b)      seen+=/BATCHFILE ;;
                            (--batch) seen+=/BATCHFILE ;;
                            (--rcvbuf) seen+=/NUMBER ;;
                            (*)       seen=$_s ;;
                            esac
                            ;;

            (BATCHFILE)     save_batchfile=$cur ;;
            (FAMILY)        __ip_match -V_s dnet inet inet6 ipx link || __ip_match_fail
                            case $_s in
                            (inet)   save_ipv=-4 ;;
                            (inet6)  save_ipv=-6 ;;
                            esac
                            ;;

            (addr)          __ip_match -V_s add change del flush list monitor replace show ||
                            __ip_match_fail
                            seen+="+$_s"
                            case $_s in
                            (add|change|del|replace) seen+="/=dev/?PREFIX" ;;
                            (flush|list|show) ;;
                            (get) seen+="/ADDR" ;;
                            esac
                            ;;

            (addr+*)        case ${expecting#*+} in
                            (flush|list|show)    _S=( anycast broadcast deprecated dev dynamic home label nodad peer permanent               primary scope secondary temporary tentative to           ) ;;
                            (add|change|replace) _S=( anycast broadcast deprecated dev dynamic home label nodad peer permanent preferred_lft primary scope secondary temporary tentative to valid_lft ) ;;
                            (del)                _S=( dev ) ;;
                            esac
                            __ip_match -V_s -S__seen_ "${_S[@]}" ||
                            __ip_match_failed
                            case $_s in
                            (anycast|broadcast)         seen+=/ADDR     ;;
                            (dev)                       seen+=/DEVICE   ;;
                            (label)                     seen+=/LABEL    ;;
                            (preferred_lft|valid_lft)   seen+=/LIFETIME ;;
                            (peer|to)                   seen+=/PREFIX   ;;
                            (scope)                     seen+=/SCOPE    ;;
                            (deprecated|dynamic|home|nodad|permanent|primary|secondary|temporary|tentative) ;;
                            esac
                            ;;

#           (addr+L)        __ip_match -V_s exact match proto root scope table type || __ip_match_fail
#                           case $_s in
#                           esac
#                           ;;

#           (addr+A1)       _S=()
#                           __ip_match -V_s dev valid_lft preferred_lft home nodad || __ip_match_fail
#                           case $_s in
#                           (*) ;;
#                           esac
#                           $seen_prefix || seen+=/?PREFIX
#                           ;;

            (addrlabel)     __ip_match -V_s add del flush list show ||
                            __ip_match_failed
                            seen+=+$_s
                            ;;

            (addrlabel+*)   __ip_match -S prefix dev label ||
                            __ip_match_failed
                            case $_s in
                            (prefix) seen+=/PREFIX ;;
                            (dev)    seen+=/DEVICE ;;
                            (label)  seen+=/LABEL ;;
                            esac
                            ;;

            (link)          __ip_match -V_s add delete list set show || __ip_match_fail
                            seen+=+$_s
                            case $_s in
                            (add)                  seen+=/=link ;;
                            (delete|set|show|list) seen+=/DEVICE ;;
                            esac
                            ;;

            (link+add)      __ip_match -V_s link name txqueuelen address broadcast mtu || __ip_match_fail
                            case $_s in
                            (link)              seen+=/DEVICE ;;
                            (address|broadcast) seen+=/LLADDR ;;
                            (name)              seen+=/NAME ;;
                            (mtu|txqueuelen)    seen+=/NUMBER ;;
                            (type)              seen=link+TYPE ;;
                            esac
                            ;;

            (link+delete)   __ip_match -V_s address broadcast link mtu name txqueuelen || __ip_match_fail
                            case $_s in
                            (link)              seen+=/DEVICE ;;
                            (type)              seen=link+TYPE ;;
                            esac
                            ;;

            (link+set)      __ip_match -V_s address alias allmulticast arp broadcast down dynamic mtu multicast name netns promisc trailers txqueuelen up vf || __ip_match_fail
                            case $_s in
                            (address|broadcast)   seen+=/LLADDR    ;;
                            (alias)               seen+=/NAME      ;;
                            (name)                seen+=/NAME      ;;
                            (mtu)                 seen+=/NUMBER32  ;;
                            (netns)               seen+=/NUMBER16  ;;
                            (txqueuelen)          seen+=/NUMBER8   ;;
                            (allmulticast|arp|dynamic|multicast|promisc|trailers) seen+=/ONOFF ;;
                            (up|down) ;;
                            (vf)                  seen+=+VFOPT/NUMBER ;;
                            esac
                            ;;

            (link+set+VFOPT)
                            __ip_match -V_s mac qos rate vlan || __ip_match_fail
                            case $_s in
                            (mac)  seen+=/LLADDR ;;
                            (qos)  seen+=/NUMBER8 ;;
                            (rate) seen+=/RATE ;;
                            (vlan) seen=link+set+VLAN/=id ;;
                            esac
                            ;;

            (link+set+VLAN) __ip_match -V_s id gvrp loose_binding reorder_hdr ingress-qos-map egress-qos-map || __ip_match_fail
                            case $_s in
                            (id) seen+=/NUM:1:4095 ;;
                            (gvrp|loose_binding|reorder_hdr) seen+=/ONOFF ;;
                            (*qos-map) seen+=/QOSMAP ;;
                            esac
                            ;;

            (link+show|link+list)
                            __ip_match -V_s ...??? || __ip_match_fail
                            case $_s in
                            esac
                            ;;

            (link+TYPE)     __ip_match -V_s can dummy ifb macvlan vcan veth vlan || __ip_match_fail
                            seen+=+$_s
                            case $_s in
                            esac
                            ;;
            (link+TYPE+can) __ip_match -V_s berr-reporting bitrate listen-only loopback one-shot phase-seg1 phase-seg2 prop-seg restart restart-ms sample-point sjw tq triple-sampling || __ip_match_fail
                            case $_s in
                            (restart)       ;;
                            (bitrate)       seen+=/NUM:1:1000000 ;;
                            (restart-ms)    seen+=/NUMBER ;;
                            (tq)            seen+=/NUMBER ;;
                            (sample-point)  seen+=/FLOAT ;;  # SAMPLE-POINT
                            (phase-seg[12]|prop-seg) seen+=/NUM:1:8 ;;
                            (sjw)           seen+=/NUM:1:4 ;;
                            (berr-reporting|listen-only|loopback|one-shot|triple-sampling) seen+=/ONOFF ;;
                            esac
                            ;;
            (link+TYPE+dummy)
                            ;;
            (link+TYPE+ifb)
                            ;;
            (link+TYPE+macvlan)
                            ;;
            (link+TYPE+vcan)
                            ;;
            (link+TYPE+veth)
                            ;;
            (link+TYPE+vlan)
                            ;;

            (maddr)         __ip_match -V_s add del list show || __ip_match_fail
                            seen+=+$_s
                            ;;

            (maddr+add)     seen+=_add/=dev/MADDR ;;
            (maddr+del)     seen+=_del/=dev/MADDR ;;
            (maddr+show|maddr+list)
                            seen+=_show/=dev ;;

            (monitor)       __ip_match -V_s all addr link maddr mroute neigh ntable route rule tunnel tuntap xfrm || __ip_match_fail
                            ;;

            (mroute)        __ip_match -V_s list show || __ip_match_fail
                            seen+=+$_s
                            case $_s in
                            (show|list) seen+=+show/PREFIX0 ;;
                            esac
                            ;;
            (mroute+show)   __ip_match -V_s from iif || __ip_match_fail
                            case $_s in
                            (from)  seen+=/PREFIX0 ;;
                            (iif)   seen+=/DEVICE ;;
                            esac
                            ;;

            (neigh)         __ip_match -V_s add change del flush list replace || __ip_match_fail
                            case $_s in
                            (add|change|del|replace) seen+=+A/ADDR ;;
                            (flush|list|show) seen+=+S ;;
                            esac
                            ;;

            (neigh+A)       __ip_match -V_s dev lladdr nud || __ip_match_fail
                            case $_s in
                            (lladdr) show+=/LLADDR ;;
                            (nud) show+=+$_s ;;
                            esac
                            ;;

            (neigh+S)       __ip_match -V_s dev nud to || __ip_match_fail
                            case $_s in
                            (dev) show+=/DEVICE ;;
                            (nud) show+=/NUD ;;
                            (to)  show+=/PREFIX0
                            esac
                            ;;

            (NUD)           __ip_match permanent noarp stale reachable || __ip_match_fail ;;

            (ntable)        __ip_match -V_s change || __ip_match_fail
                            seen+=+$_s
                            ;;

            (route)         __ip_match -V_s add append change del flush get list show replace monitor || __ip_match_fail
                            case $_s in
                            (add|append|change|del|monitor|replace) seen+=+A/=dev/PREFIX0/route+R ;;
                            (get)                                   seen+=+get/ADDR   ;;
                            (flush|list|show)                       seen+=+L ;;
                            esac
                            ;;
            (route+R)       __ip_match -V_s blackhole broadcast local multicast nat prohibit throw unicast unreachable ||
                            __ip_match_empty
                            seen+=/route+R+$_s
                            ;;

            (route+A)       __ip_match -V_s blackhole broadcast default dev local multicast nat prohibit throw unicast unreachable via weight ||
                            __ip_match_failed
                            case $_s in
                            (default)       seen+= ;;
                            (via)           seen+=/ADDR ;;
                            (weight)        seen+=/NUMBER ;;
                            (dev)           seen+=/DEVICE ;;
                            (blackhole)     seen+=/PREFIX0 ;;
                            (broadcast)     seen+=/PREFIX0 ;;
                            (local)         seen+=/PREFIX0 ;;
                            (multicast)     seen+=/PREFIX0 ;;
                            (nat)           seen+=/PREFIX0 ;;
                            (prohibit)      seen+=/PREFIX0 ;;
                            (throw)         seen+=/PREFIX0 ;;
                            (unicast)       seen+=/PREFIX0 ;;
                            (unreachable)   seen+=/PREFIX0 ;;
                            esac
                            ;;

            (route+L)       __ip_match -V_s exact match proto root scope table type || __ip_match_failed
                            case $_s in
                            (exact) seen+=/PREFIX0   ;;
                            (match) seen+=/PREFIX0   ;;
                            (proto) seen+=/RTPROTO  ;;
                            (root)  seen+=/PREFIX0   ;;
                            (scope) seen+=/SCOPE    ;;
                            (table) seen+=/TABLE+   ;;
                            (type)  seen+=/RTYPE    ;;
                            esac
                            ;;

            (route+get)     __ip_match -V_s from oif tos || __ip_match_failed
                            case $_s in
                            (from)      seen+=/=iif/ADDR ;;
                            (iif|oif)   seen+=/IFACE     ;;
                            (tos)       seen+=/TOS       ;;
                            esac
                            ;;

            (route+P)     # ROUTE -> NODE_SPEC -> [RTYPE] PREFIX
                            __ip_match -V_s advmss cwnd dev equalize initcwnd metric mtu nexthop proto realms rto_min rtt rttvar scope src ssthresh table tos via weight window ||
                            __ip_match_fail

                            case $_s in
                            (advmss|weight)     seen+=/NUMBER16 ;;
                            (cwnd|initcwnd|mtu) seen+=/NUMBER32 ;;
                            (dev)               seen+=/IFACE    ;;
                            (equalize|onlink|pervasive)         ;;
                            (metric)            seen+=/NUMBER31S ;;
                            (nexthop)                           ;;  # TODO - reset the "seen" states
                            (proto)             seen+=/RTPROTO  ;;
                            (realms)            seen+=/REALM    ;;
                            (rto_min|rtt|rttvar) seen+=/TIME    ;;
                            (scope)             seen+=/SCOPE    ;;
                            (src|via)           seen+=/ADDR     ;;
                            (ssthresh)          seen+=/NUMBER   ;;
                            (table)             seen+=/TABLE    ;;
                            (tos)               seen+=/TOS      ;;
                            (window)            seen+=/NUMBER8  ;;
                            esac
                            ;;

            (rule)          $last_arg && COMPREPLY+=( add del flush list show ) && break ;&
            (rule/[ad]*)    seen+=_A     ;; # add/del
            (rule/[lfs]*)   seen+=_L     ;; # flush/list/show
            (rule_A/*)      $last_arg && COMPREPLY+=( dev from fwmark goto iif lookup not pref prio prohibit realms reject table to tos unreachable ) && break ;;
            (rule_A/d*)     seen+=/DEVICE   ;; # dev
            (rule_A/fr*)    seen+=/PREFIX0   ;; # from
            (rule_A/fw*)    seen+=/NUMBER32   ;; # fwmark
            (rule_A/g*)     seen+=/NUMBER   ;; # goto
            (rule_A/i*)     seen+=/DEVICE   ;; # iif
            (rule_A/l*)     seen+=/TABLE    ;; # lookup=table
            (rule_A/n*)                     ;; # not
            (rule_A/pre*)   seen+=/NUMBER   ;; # pref
            (rule_A/pri*)   seen+=/NUMBER   ;; # prio
            (rule_A/pro*)                   ;; # prohibit
            (rule_A/rea*)   seen+=/REALM    ;; # realm
            (rule_A/rej*)                   ;; # reject
            (rule_A/ta*)    seen+=/TABLE    ;; # table
            (rule_A/to)     seen+=/PREFIX0   ;; # to
            (rule_A/tos)    seen+=/TOS      ;; # tos
            (rule_A/u*)                     ;; # unreachable
            (rule_L/*)      $last_arg && break ;&

            (tunnel)        __ip_match -V_s add change del list show || __ip_match_fail
                            seen+=+$_s ;;

            (tuntap)        __ip_match_TODO ;;

            (xfrm)          __ip_match -V_s policy state monitor || __ip_match_fail
                            seen+=+$_s ;;

            (ADDR)          __ip_match_addr $save_ipv $cur || __ip_match_fail ;;
            (MADDR)         __ip_match_addr $save_ipv -m $cur || __ip_match_fail ;;
            (LLADDR)        __ip_match_addr -0 $cur || __ip_match_fail ;;
            (PREFIX0)       __ip_match_addr $save_ipv -P -d $cur || __ip_match_fail ; seen_prefix=true ;;
            (PREFIX)        __ip_match_addr $save_ipv -P    $cur || __ip_match_fail ; seen_prefix=true ;;

            (DEVICE)        __ip_match -Vsave_device $(ip -o link list | sed -e "s/^[0-9]*: //; s/: .*//; /^wmaster/d" ) ||
                            __ip_match_failed ;;
            (LIFETIME)      __ip_match forever ||
                            __ip_match_number --8bit ||
                            __ip_match_fail ;;
            (NUM:*:*)       _s=${expecting#NUM:} min_num=${_s%:*} max_num=${_s#*:}
                            __ip_match_number --min=$min_num --max=$max_num || __ip_match_fail ;;
            (NUM:*)         __ip_match_number --max=${expecting##*:} || __ip_match_fail ;;
            (NUMBER)        __ip_match_number || __ip_match_fail ;;
            (NUMBER8)       __ip_match_number --8bit || __ip_match_fail ;;
            (NUMBER16)      __ip_match_number --16bit || __ip_match_fail ;;
            (NUMBER32)      __ip_match_number --32bit || __ip_match_fail ;;
            (NUMBER31S)     __ip_match_number --s32bit || __ip_match_fail ;;
            (ONOFF)         __ip_match on off || __ip_match_fail ;;
            (QOSMAP)        __ip_warning "QOSMAP not implemented" ;;
            (REALM)         __ip_match $(__ip_slurp /etc/iproute2/rt_realms) ||
                            __ip_match_number --8bit ||
                            __ip_match_fail ;;
            (SCOPE)         __ip_match_number --8bit ||
                            __ip_match $( __ip_slurp /etc/iproute2/rt_scopes ) ||
                            __ip_match_fail ;;
            (LABEL)         __ip_match $save_device: || true ;;
            (TABLE)         __ip_match default local main '$( __ip_slurp /etc/iproute2/rt_tables )' ||
                            __ip_match_number --8bit ||
                            __ip_match_fail ;;
            (TABLE+)        __ip_match all default local main '$( __ip_slurp /etc/iproute2/rt_tables )' ||
                            __ip_match_number --max=255 --min=-2 ||
                            __ip_match_fail ;;
            (RTYPE)         __ip_match blackhole broadcast local multicast nat prohibit throw unicast unreachable ||
                            __ip_match_fail ;;
            (RTPROTO)       __ip_match boot kernel static ||
                            __ip_match_number --8bit ||
                            __ip_match_fail;;
            (TOS)           __ip_match inherit ||
                            __ip_match_number --8bit ||
                            __ip_match_fail ;;

            #([A-Z]*/*)      ;;

            (*)             __ip_error "Lost sync? seen=$seen expect=$expecting cur=$cur" ;;

            esac  # }}}

        done  # }}}

        __ip_debug "COMPREPLY=[${COMPREPLY[*]}] (before compgen)"

        COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -- $cur ) )

        __ip_debug "COMPREPLY=[${COMPREPLY[*]}] (after compgen)"

        ((${#COMPREPLY[@]} == 0)) && {
            __ip_debug "No matches for '$cur'"
            return 1
        }

        # If only one possibility exists, add a space
        ((${#COMPREPLY[@]} == 1)) && [[ $COMPREPLY != *[.:/] ]] && COMPREPLY="${COMPREPLY% } "

        # completion treats colons as if they were word-separators, and appends to current word rather than replacing it
        if [[ $cur = *:* ]]
        then
            local rword_index
            cur=${cur%:*}:
            for ((rword_index=0 ; rword_index<${#COMPREPLY[@]} ; rword_index++ )) do
                COMPREPLY[rword_index]="${COMPREPLY[rword_index]#$cur}"
            done
        fi

        return 0
    done  # }}} end dummy loop
    COMPREPLY=()
    __ip_warning "Lost sync? seen=$seen expect=$expecting cur=$__cur"
    return 1
}
#COMP_VERBOSE=false
complete -F _ip -o nospace ip
