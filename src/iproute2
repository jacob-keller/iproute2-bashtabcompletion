#! library/module/for/bash
#
# ip (iproute2) command-line completion for Bash.
#
# Written by Martin D Kealey <martin@kurahaupo.gen.nz>
#
# Released at LCA2010, 19 January 2010.
#
# You may copy and use this program under the terms of version two of the Gnu Public Licence, or
# any later version as published by the Free Software Foundation.
#

[[ $(type -t have) != function ]] || have ip || return

__ip_slurp()
{
    sed -e '
             s/#.*//
             s/[ 	][ 	]*/ /g
             s/ $//
             s/^[0-9][0-9]* //
             /^$/d
             s/ /\n/g
            ' $1
}

__ip_strtrunc()
{
    local w=$1 ; shift
    local p="$*"
    ((${#p} > w)) && p="${p:0:w-3}..."
    echo "$p"
}

__ip_debug() { : ; }
__ip_debug_parsing_state() { : ; }
__ip_debug_unexpected() { : ; }
__ip_error() { : ; }
__ip_warning() { : ; }

__ip_complete_address()
{
    local accept_link=false accept_ipv4=false accept_ipv6=false accept_prefix=false \
          require_prefix=false require_multicast=false

    while (($#)) ; do  case $1 in
    (--) shift ; break ;;
    (-0) accept_link=true ;;
    (-46|-64) accept_ipv4=true accept_ipv6=true ;;
    (-4) accept_ipv4=true ;;
    (-6) accept_ipv6=true ;;
    (-p) accept_prefix=true ;;
    (-P) require_prefix=true accept_prefix=true ;;
    (-m) require_multicast=true ;;
    (-*) ;;
    (*) break ;;
    esac ; shift ; done

    local cur=$1
    local cus=${cur%/*}

    __ip_debug "Completing address starting with '$cur': link=$accept_link ipv4=$accept_ipv4 ipv6=$accept_ipv6 prefix=$accept_prefix/$require_prefix "

    if ! $accept_prefix && [[ $cur = */* ]]
    then
        __ip_warning "Not expecting a prefix"
        COMPREPLY+=($cus)
        return 1
    fi

    [[ $cur = *[^:0-9a-f]* || $cur = *[^:][^:][^:]* || $cur = *::* || :$cur = *:?:* || $cur = :* || $cur = *:*:*:*:*:*:* ]] && accept_link=false
    [[ $cur = */*[^0-9]* ]] && accept_prefix=false
    [[ $cus = *[^.0-9]*     || $cus = *[^0.][^.][^.][^.]*          || $cur = *.*.*.*.*         || $cur = .*    || $cur = *.[./]* ]] && accept_ipv4=false
    [[ $cus = *[^.0-9:a-f]* || $cus = *[^0:.][^:.][^:.][^:.][^:.]* || $cur = *:*:*:*:*:*:*:*:* || $cur = *:::* || $cur = *.*:*   || ( $cur = *.* && $cur != ::* ) ]] && accept_ipv6=false

    # sanity check
    $accept_link || $accept_ipv4 || $accept_ipv6 || {
        __ip_warning "Invalid address; neither Link nor IPv4 nor IPv6 possible"
        return 1
    }

    if $require_prefix
    then
        if ! $accept_prefix
        then
            __ip_warning "Invalid prefix /${cur#*/}"
            return 1
        fi
        if [[ $cur = ::/* || $cur = 0.* || $cur = */0 ]]
        then
            COMPREPLY+=(default)
            return 0
        fi
    fi

    local d19="${cur}1 ${cur}2 ${cur}3 ${cur}4 ${cur}5 ${cur}6 ${cur}7 ${cur}8 ${cur}9"
    local d09="${cur}0 $d19"
    local d0f="$d09 ${cur}a ${cur}b ${cur}c ${cur}d ${cur}e ${cur}f"

    if [[ $cur = */* ]]
    then
        local pref_len=${cur##*/} max_pref_len=32
        $accept_ipv6 && max_pref_len=128

        [[ $pref_len = *[^0-9]* ]] && {
            __ip_error "Prefix-length '$pref_len' is non-numeric"
            return 1
        }
        (( pref_len > max_pref_len )) && {
            __ip_error "Prefix-length '$pref_len' is greater than $max_pref_len"
            return 1
        }

        if (( pref_len * 10 > max_pref_len ))
        then
            __ip_warning "Prefix length is greater than ${max_pref_len%?}, therefore we're finished"
            COMPREPLY+=($cur)
        else
            COMPREPLY+=($d09)
        fi
    else
        if $require_multicast && [[ $cur != *[:.]* ]]
        then
            $accept_link && COMPREPLY+=( ff:ff:ff:ff:ff:ff )
            $accept_ipv4 && COMPREPLY+=( 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 )
            $accept_ipv6 && COMPREPLY+=( ffc0:: )
            __ip_debug "Start of multicast range"
            return 0
        fi

        local last_term=${cur##*[:.]}

        if  # is last word of address complete?
            { $accept_ipv6 && [[ $last_term = [0-9a-f][0-9a-f][0-9a-f][0-9a-f] ]] ; } ||
            { $accept_ipv4 &&
                [[ $last_term != *[^0-9]* &&
                   $last_term = [0-9]* ]] &&
                (( last_term >= 26 ||
                   last_term == 0 )) ; }
        then
            :
        elif $accept_ipv6
        then COMPREPLY+=($d0f)
        elif [[ $last_term = '' ]]
        then COMPREPLY+=($d09)
        else COMPREPLY+=($d19)
        fi

        { { $accept_link && [[ $cur != *:*:*:*:*:*     && $cur != *: ]] ; } ||
          { $accept_ipv6 && [[ $cur != *:*:*:*:*:*:*:* && $cur != *:: && $cur != *.* ]] ; }
        } && COMPREPLY+=($cur:)

        [[ $cur != *.*.*.* && .$cur != *. ]] &&
        { { $accept_ipv4 && [[ $cur != *[^.0-9]* ]] ; } ||
          { $accept_ipv6 && [[ ( $cur = ::ffff:* && $cur != ::ffff:*[^.0-9]* ) ||
                              ( $cur =      ::* && $cur !=      ::*[^.0-9]* ) ]] ; }
        } && COMPREPLY+=($cur.)

        $accept_prefix && [[ $cur = *::* || $cur = *:*:*:*:*:*:*:* || $cur = *.*.*.*[0-9] ]] && COMPREPLY+=($cur/)

    fi

    __ip_debug "Completed compreply=[$(__ip_strtrunc 20 "${COMPREPLY[*]}")] (count=${#COMPREPLY[*]})"

    return 0
}

_ip()
{
    local -a expect
    local cur i seen
    local save_device save_ipv=-46

    COMPREPLY=()

    if $COMP_VERBOSE
    then
        echo >&2 $'\e7\e[A\e[999I\e[43;30m\e[1J\e[H'"Completion START: WORDS=(${COMP_WORDS[*]}) CWORD=$COMP_CWORD"
        trap " trap RETURN ; echo -n >&2 'Completion END: COMPREPLY=('\${COMPREPLY[*]}')'\$'\\e[49;39;0m\\e8' " RETURN
        __ip_debug() { echo >&2 "Completion $*" ; }
        __ip_debug_parsing_state() { echo >&2 "Completion STATE $*word[$i]: seen=$seen curr=$cur expect=(${expect[*]})" ; }
        __ip_debug_unexpected() { echo >&2 "Completion UNEXPECTED $*" ; }
        __ip_error() { echo >&2 "Completion ERROR $*" ; }
        __ip_warning() { echo >&2 "Completion WARNING $*" ; }
    else
        __ip_debug() { : ; }
        __ip_debug_parsing_state() { : ; }
        __ip_debug_unexpected() { : ; }
        __ip_error() { local t="$*" ; local l=${#t} ; echo -n >&2 $'\e[1K\e[33m'$t$'\e[39m\e['$l'D' ; }
        __ip_warning() { : ; }
    fi

    # Establish parsing state:
    seen=START expect=(START) cur="(start-of-line)"
    __ip_debug_parsing_state
    for ((i=1;i<COMP_CWORD;i++)) do
        cur=${COMP_WORDS[i]}

        expecting=$expect ; unset expect[0] ; expect=("${expect[@]}")

        __ip_debug "Matching on \"$expecting:$cur\""
        # If we're expecting a specific word
        if [[ $expecting = ="$cur"* ]] ; then
            # process word based on seen state rather than on the explicit expectation
            expecting=$seen
        elif [[ $expecting = =* ]] ; then
            # didn't find it!
            __ip_error "Expecting '${expecting#=}' instead of '$cur'"
            return 1
        fi

        __ip_debug "Matching \"$expecting:$cur\" with seen=$seen"
        case $expecting:$cur in

        (START:-f*\
        |START:--f*)    expect=(FAMILY START) ;;
        (START:-[46])   save_ipv=$cur ;;
        (START:-*) ;;

        (START:a*)      seen=addr ;;
        (START:l*)      seen=link ;;
        (START:ma*)     seen=maddr ;;
        (START:mo*)     seen=monitor ;;
        (START:mr*)     seen=mroute ;;
        (START:ne*)     seen=neigh ;;
        (START:nt*)     seen=ntable ;;
        (START:ro*)     seen=route ;;
        (START:ru*)     seen=rule ;;
        (START:t*)      seen=tunnel ;;
        (START:x*)      seen=xfrm ;;

        (addr:a*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # add
        (addr:c*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # change
        (addr:d*)       seen=addr_D expect=(ADDR =dev DEVICE) ;; # del
        (addr:f*)       seen=addr_S                           ;; # flush
        (addr:l*)       seen=addr_S                           ;; # list (alias for show)
        (addr:r*)       seen=addr_A expect=(ADDR =dev DEVICE) ;; # replace
        (addr:s*)       seen=addr_S                           ;; # show

        (addr_?:a*)     expect=(ADDR)   ;; # anycast
        (addr_?:b*)     expect=(ADDR)   ;; # broadcast
        (addr_?:dep*)                   ;; # deprecated
        (addr_?:dy*)                    ;; # dynamic
        (addr_?:d*)     expect=(DEVICE) ;; # dev
        (addr_?:h*)                     ;; # home
        (addr_?:l*)     expect=(LABEL)  ;; # label
        (addr_?:n*)                     ;; # nodad
        (addr_?:per*)                   ;; # permanent
        (addr_?:p*)     expect=(PREFIX) ;; # peer
        (addr_?:pre*)   expect=(LFT)    ;; # preferred_lft
        (addr_?:pri*)                   ;; # primary
        (addr_?:se*)                    ;; # secondary
        (addr_?:s*)     expect=(SCOPE)  ;; # scope
        (addr_?:te*)                    ;; # tentative
        (addr_?:t*)     expect=(PREFIX) ;; # to
        (addr_?:v*)     expect=(LFT)    ;; # valid_lft

        (link:l*)       seen=link_L expect=(DEVICE) ;;  # list (alias for show)
        (link:se*)      seen=link_S  expect=(DEVICE) ;;
        (link:sh*)      seen=link_L expect=(DEVICE) ;;

        (link_S:ad*)    expect=(LLADDR)  ;; # address
        (link_S:al*)    expect=(ONOFF)   ;; # allmulticast
        (link_S:ar*)    expect=(ONOFF)   ;; # arp
        (link_S:b*)     expect=(LLADDR)  ;; # broadcast
        (link_S:d*)                      ;; # down
        (link_S:dy*)    expect=(ONOFF)   ;; # dynamic
        (link_S:mt*)    expect=(NUMBER32) ;; # mtu
        (link_S:mu*)    expect=(ONOFF)   ;; # multicast
        (link_S:n*)     expect=(NEWNAME) ;; # name
        (link_S:p*)     expect=(ONOFF)   ;; # promisc
        (link_S:tr*)    expect=(ONOFF)   ;; # trailers
        (link_S:tx*)    expect=(NUMBER8) ;; # txqueuelen
        (link_S:u*)                      ;; # up

        (maddr:a*)      seen=maddr_add  expect=(MADDR =dev DEVICE) ;;
        (maddr:d*)      seen=maddr_del  expect=(MADDR =dev DEVICE) ;;
        (maddr:s*)      seen=maddr_show expect=(      =dev DEVICE) ;;

        (monitor:*)     ;;

        (mroute:[sl]*)  seen=mroute_S expect=(PREFIX) ;; # list, show
        (mroute_S:f*)   expect=(PREFIX) ;;  # from
        (mroute_S:i*)   expect=(DEVICE) ;;  # iif

        (neigh:a*)      seen=neigh_A expect=(ADDR) ;; # add
        (neigh:c*)      seen=neigh_A expect=(ADDR) ;; # change
        (neigh:d*)      seen=neigh_A expect=(ADDR) ;; # del
        (neigh:f*)      seen=neigh_S    ;; # flush
        (neigh:l*)      seen=neigh_S    ;; # list, alias for show
        (neigh:r*)      seen=neigh_A expect=(ADDR) ;; # replace
        (neigh:s*)      seen=neigh_S    ;; # show
        (neigh_A:*)     expect=(ADDR) ;;
        (neigh_S:*)     ;;

        (ntable:*)      seen=ntable_$cur ;;

        (route:a*)      seen=route_A    ;; # add/append
        (route:c*)      seen=route_A    ;; # change
        (route:d*)      seen=route_A    ;; # del
        (route:f*)      seen=route_L    ;; # flush
        (route:g*)      seen=route_G expect=(ADDR) ;; # get
        (route:l*)      seen=route_L    ;; # list
        (route:m*)      seen=route_A    ;; # monitor
        (route:r*)      seen=route_A    ;; # replace
        (route:s*)      seen=route_L    ;; # show (alias for list)

        (route_L:e*)    expect=(PREFIX) ;; # exact
        (route_L:m*)    expect=(PREFIX) ;; # match
        (route_L:p*)    expect=(RTPROTO) ;; # proto
        (route_L:r*)    expect=(PREFIX) ;; # root
        (route_L:s*)    expect=(SCOPE)  ;; # scope
        (route_L:ta*)   expect=(TABLE+)  ;; # table
        (route_L:ty*)   expect=(RTYPE)  ;; # type

        (route_G:f*)    expect=(ADDR =iif IFACE) ;; # from
        (route_G:i*)    expect=(IFACE)  ;; # iif
        (route_G:o*)    expect=(IFACE)  ;; # oif
        (route_G:t*)    expect=(TOS)    ;; # tos

        (route_A:b[lr]*\
        |route_A:[lmnpt]*\
        |route_A:un[ir]*) seen=route_P expect=(PREFIX) ;;  # still seen route-add-type, now expecting PREFIX-[TTPSM], then [INFO_SPEC]

        (route_A:*)     seen=route_P    ;; # seen route-add-[type]-prefix

        (route_P:a*)    expect=(NUMBER16) ;; # advmss
        (route_P:c*)    expect=(NUMBER32) ;; # cwnd
        (route_P:d*)    expect=(IFACE)  ;; # dev
        (route_P:e*)                    ;; # equalize
        (route_P:i*)    expect=(NUMBER32) ;; # initcwnd
        (route_P:me*)   expect=(NUMBER31S) ;; # metric
        (route_P:mt*)   expect=(NUMBER32) ;; # mtu
        (route_P:n*)                    ;; # nexthop
        (route_P:o*)                    ;; # onlink
        (route_P:pr*)   expect=(RTPROTO) ;; # proto
        (route_P:pe*)                   ;; # pervasive
        (route_P:re*)   expect=(REALM)  ;; # realms
        (route_P:rto*)  expect=(TIME)   ;; # rto_min
        (route_P:rtt*)  expect=(TIME)   ;; # rtt or rttvar
        (route_P:sc*)   expect=(SCOPE)  ;; # scope
        (route_P:sr*)   expect=(ADDR)   ;; # src
        (route_P:ss*)   expect=(NUMBER) ;; # ssthresh
        (route_P:ta*)   expect=(TABLE)  ;; # table
        (route_P:to*)   expect=(TOS)    ;; # tos
        (route_P:v*)    expect=(ADDR)   ;; # via
        (route_P:we*)   expect=(NUMBER16) ;; # weight
        (route_P:wi*)   expect=(NUMBER8) ;; # window

        (rule:[ad]*)    seen=rule_A     ;; # add/del
        (rule:[lfs]*)   seen=rule_L     ;; # flush/list/show
        (rule_A:d*)     expect=(DEVICE) ;; # dev
        (rule_A:fr*)    expect=(PREFIX) ;; # from
        (rule_A:fw*)    expect=(NUMBER32) ;; # fwmark
        (rule_A:g*)     expect=(NUMBER) ;; # goto
        (rule_A:i*)     expect=(DEVICE) ;; # iif
        (rule_A:l*)     expect=(TABLE)  ;; # lookup=table
        (rule_A:n*)                     ;; # not
        (rule_A:pre*)   expect=(NUMBER) ;; # pref
        (rule_A:pri*)   expect=(NUMBER) ;; # prio
        (rule_A:pro*)                   ;; # prohibit
        (rule_A:rea*)   expect=(REALM)  ;; # realm
        (rule_A:rej*)                   ;; # reject
        (rule_A:ta*)    expect=(TABLE)  ;; # table
        (rule_A:to)     expect=(PREFIX) ;; # to
        (rule_A:tos)    expect=(TOS)    ;; # tos
        (rule_A:u*)                     ;; # unreachable

        (tunnel:*)      seen=tunnel_${cur:0:1} ;;

        (FAMILY:inet4)  save_ipv=-4 ;;
        (FAMILY:inet6)  save_ipv=-6 ;;
        (FAMILY:link)   ;;
        (DEVICE:*)      save_device=$cur ;;
        ([A-Z]*:*)      ;;

        (*)             __ip_error "Lost sync? seen=$seen expect=$expecting cur=$cur" ; return 1 ;;

        esac
        : ${expect:=${seen%/*}}

        __ip_debug_parsing_state
    done
    cur=$(_get_cword)

    local or_digits=false or_prefix=false max_num= min_num=

    case $expect in
    (START) COMPREPLY+=( addr link maddr monitor mroute neigh ntable route rule \
                      tunnel xfrm --details --family --oneline --resolve \
                      --statistics --timestamp --verbose --Version -0 -4 -6 \
                      -d -f -o -r -s -t -v -V ) ;;

    (addr)  COMPREPLY+=( add change flush del list show replace monitor ) ;;
    (addr_A)
            COMPREPLY+=( anycast broadcast deprecated dev dynamic home label \
                      nodad peer permanent preferred_lft primary scope \
                      secondary tentative to valid_lft ) ;;
    (addr_D)
            COMPREPLY+=( dev ) ;;
    (addr_S)
            COMPREPLY+=( anycast broadcast deprecated dev dynamic home label \
                      nodad peer permanent primary scope secondary tentative \
                      to ) ;;

    (link)  COMPREPLY+=( list show set ) ;;
    (link_S)
            COMPREPLY+=( address allmulticast arp broadcast down dynamic mtu \
                      multicast name promisc trailers txqueuelen up ) ;;

    (maddr) COMPREPLY+=( add del list show ) ;;

    (monitor)
            COMPREPLY+=( all addr link maddr mroute neigh ntable route rule tunnel xfrm ) ;;

    (mroute)
            COMPREPLY+=( list show ) ;;

    (neigh)
            COMPREPLY+=( add change del replace ) ;;

    (ntable)
            COMPREPLY+=( change ) ;;

    (route) COMPREPLY+=( add append change del flush get list show replace monitor ) ;;
    (route_G)
            COMPREPLY+=( from oif tos ) ;;
    (route_L)   # RTSELECTOR
            COMPREPLY+=( root match exact table proto type scope ) ;;
    (route_A)   # ROUTE -> NODE_SPEC -> [TYPE] PREFIX
            COMPREPLY+=( via dev weight unicast local broadcast multicast \
                      throw unreachable prohibit blackhole nat default )
            or_prefix=true ;;
    (route_P)   # ROUTE -> NODE_SPEC -> [TYPE] PREFIX
            COMPREPLY+=( advmss cwnd dev equalize initcwnd metric mtu nexthop \
                      proto realms rto_min rtt rttvar scope src ssthresh \
                      table tos via weight window ) ;;

    (rule)  COMPREPLY+=( add del flush list show ) ;;
    (rule_A)
            COMPREPLY+=( dev from fwmark goto iif lookup not pref prio prohibit \
                      realms reject table to tos unreachable ) ;;
    (rule_L)
            ;;

    (tunnel)
            COMPREPLY+=( add change del list show ) ;;

    (xfrm)  COMPREPLY+=( policy state monitor ) ;;

    (=*)    COMPREPLY+=( ${expect#=} ) ;;

    (DEVICE)
            COMPREPLY+=( '$(ip -o link list | sed -e "s/^[0-9]*: //; s/: .*//; /^wmaster/d" )' ) ;;
    (FAMILY)
            COMPREPLY+=( inet inet6 ipx dnet link ) ;;
    (LFT)   COMPREPLY+=( forever ) or_digits=true max_num=255 ;;
    (NUMBER)
            or_digits=true ;;
    (NUMBER8)
            or_digits=true max_num=0xff ;;
    (NUMBER16)
            or_digits=true max_num=0xffff ;;
    (NUMBER32)
            or_digits=true max_num=0xffffffff ;;
    (NUMBER31S)
            or_digits=true min_num=-0x80000000 max_num=0x7fffffff ;;
    (ONOFF) COMPREPLY+=( on off ) ;;
    (REALM) COMPREPLY+=( '$(__ip_slurp /etc/iproute2/rt_realms)' )
            or_digits=true max_num=0xff ;;
    (SCOPE) COMPREPLY+=( '$( __ip_slurp /etc/iproute2/rt_scopes )' ) ;;
    (ADDR)  __ip_complete_address $save_ipv $cur || return $? ;;
    (MADDR) __ip_complete_address $save_ipv -m $cur || return $? ;;
    (LLADDR)
            __ip_complete_address -0 $cur ;;
    (PREFIX)
            __ip_complete_address $save_ipv -P $cur || return $? ;;
    (LABEL) COMPREPLY+=( $save_device: ) ;;
    (TABLE) COMPREPLY+=( default local main '$( __ip_slurp /etc/iproute2/rt_tables )' )
            or_digits=true max_num=255 ;;
    (TABLE+)
            COMPREPLY+=( all default local main '$( __ip_slurp /etc/iproute2/rt_tables )' )
            or_digits=true max_num=255 min_num=-2 ;;
    (RTYPE) COMPREPLY+=( blackhole broadcast local multicast nat prohibit throw \
                      unicast unreachable ) ;;
    (RTPROTO)
            COMPREPLY+=( boot kernel static ) or_digits=true max_num=255 ;;
    (TOS)   COMPREPLY+=( inherit ) or_digits=true max_num=255 ;;

    (K_options) ;;

    (*)     __ip_error "Undefined expect=[$expect] seen=[${seen##*/}]" ;;
    esac

    __ip_debug "COMPREPLY=[${COMPREPLY[*]}] or_digits=$or_digits or_prefix=$or_prefix cur=$cur"

    $or_prefix && __ip_complete_address $save_ipv -p $cur

    if $or_digits && [[ ${cur#-} != *[^0-9]* ]]
    then
        [[ $cur != '-' ]] && COMPREPLY+=( ${cur} )
        if (( (!${#max_num} || cur*10 <= max_num) &&
              (!${#min_num} || cur*10 >= min_num) ))
        then COMPREPLY+=( ${cur}0 ${cur}1 ${cur}2 ${cur}3 ${cur}4 \
                          ${cur}5 ${cur}6 ${cur}7 ${cur}8 ${cur}9 )
        fi
    fi

    COMPREPLY=( $( compgen -W "${COMPREPLY[*]}" -- $cur ) )

    ((${#COMPREPLY[@]} == 0)) && {
        __ip_debug "No matches for '$cur'"
        return 1
    }

    # completion treats colons as if they were word-separators, and appends to current word rather than replacing it
    [[ $cur = *:* ]] &&
    for ((i=0 ; i<${#COMPREPLY[@]} ; i++ )) do
        COMPREPLY[i]="${COMPREPLY[i]#${cur%:*}:}"
    done

    ((${#COMPREPLY[@]} == 1)) && [[ $COMPREPLY != *[.:] ]] && COMPREPLY="${COMPREPLY% } "

    return 0
}

#COMP_VERBOSE=false
complete -F _ip -o nospace ip
